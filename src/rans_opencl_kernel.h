#ifndef rans_opencl_kernel_h__
#define rans_opencl_kernel_h__

const char *kernelsource =
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"\n"
"#define NX 32\n"
"\n"
"#define TF_SHIFT 12\n"
"#define TOTFREQ (1<<TF_SHIFT)\n"
"#define RANS_BYTE_L (1u << 15)\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(NX, 1, 1)))\n"
"void decode_ans(global ushort *pIn, global uchar *pOut, uint outOffset, uint symbolCount, uint overhang, global uint *pS3, global uint *pR, global uchar *pSsym)\n"
"{\n"
"  global uchar *pOutData = pOut + outOffset;\n"
"\n"
"  __local uint s3[TOTFREQ];\n"
"  __local uint R[NX];\n"
"\n"
"  const uint mask = (1u << TF_SHIFT) - 1;\n"
"\n"
"  uint index = get_local_id(0);\n"
"\n"
"  if (index == 0)\n"
"  {\n"
"    for (int i = 0; i < TOTFREQ; i++)\n"
"      s3[i] = pS3[i];\n"
"  }\n"
"\n"
"  R[index] = pR[index];\n"
"\n"
"  for (uint i = index; i < symbolCount; i += NX)\n"
"  {\n"
"    uint S = s3[R[index] & mask];\n"
"    R[index] = (S >> (TF_SHIFT + 8)) * (R[index] >> TF_SHIFT) + ((S >> 8) & mask);\n"
"    pOutData[i] = (uchar)(S);\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    \n"
"    if (index == 0)\n"
"    {\n"
"      for (int j = 0; j < NX; j++)\n"
"      {\n"
"        if (R[j] < RANS_BYTE_L)\n"
"        {\n"
"          R[j] = (R[j] << 16) | *pIn;\n"
"          pIn++;\n"
"        }\n"
"      }\n"
"    }\n"
"    \n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"  }\n"
"\n"
"  if (index == 0)\n"
"  {\n"
"    for (uint z = overhang; z-- > 0; )\n"
"      pOutData[symbolCount + z] = pSsym[R[z] & mask]; \n"
"  }\n"
"}\n"
"\n";

#endif // rans_opencl_kernel_h__
